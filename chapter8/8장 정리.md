# 8장 정리

## next.js란?

next.js 공식문서 주소(https://nextjs.org/docs/app/building-your-application/routing/defining-routes)

React의 SSR을 쉽게 도와주는 프레임워크

- CSR(Client Side Rendering): 클라이언트에서 페이지를 전송
- SSR(Server Side Rendering): 서버에서 페이지를 전송

CSR은 SSR에 비해 네트워크 트레픽에 최적화 되어 서버에 부하가 적다는 장점이 있음
SSR은 CSR과 달리 렌더링된 페이지를 서버에서 전송하므로 검색엔진 노출에 더 유리

## Pre-rendering

pre(prevent)-rendering는 '사전에 렌더링' 한다는 의미로 모든 페이지를 위한 HTML을 Client Side에서 처리 전에 함

## NEXT13 라우팅

### 1. page 라우팅

- app디렉토리 내에 page.js를 생성(/)
- app디렉토리 내에 posts디렉토리 생성 후 내에 page.js파일 생성(/posts)
- posts디렉토리 내에 settings디렉토리 생성 후 내에 page.js파일 생성(/posts/settings)

위와 같은 방식으로 `npm run build` or `yarn build` 시 자동 라우팅

### 2. layout 라우팅

- app디렉토리 내에 layout.js를 생성
- 상태를 보존하고 페이지에 제약을 받지 않으며 최초 렌더링 후 리렌더링 되지 않음
- 위와같은 특성으로 navigation, sidemenu등에 주로 활용

### 3. Link와 useRoute

- next/link 내장 기능 이용하여 Link기능 사용 가능
- Link 사용 시 HTML 요청 없이 SSR 환경에서 로드or이동 가능

```ts
import Link from 'next/link';

<Link href={`/posts`}>{post.title}</Link>;
```

- CRS일 때는 아래와 같이 useRouter를 이용

```ts
'use client';

import { useRouter } from 'next/navigation';

export default function Page() {
  const router = useRouter();

  return (
    <button type="button" onClick={() => router.push('/posts')}>
      posts
    </button>
  );
}
```

### 4. 루트 그룹 설정

- 디렉토리의 이름을 ()로 감싸면 그룹으로 설정 가능
- 그룹으로 설정된 디렉토리는 라우트 경로에서 제외됨(개발자 편의를 위한 기능)

- app에 (announcement)디렉토리와 (dashboard)디렉토리 생성
- (announcement)에 posts디렉토리 및 page.js 생성(/posts)
- (dashboard)디렉토리에 maintenance디렉토리 및 page.js 생성(/maintenance)

### 5. 동적 라우팅

- 디렉토리의 이름을 []로 감싸면 동적으로 라우팅이 가능

```ts
export default function Page({ params }: { params: { slug: string } }) {
  return <div>My Post: {params.slug}</div>;
}
```

- app/blog/[slug]/page.js /blog/a { slug: 'a' }
- app/blog/[slug]/page.js /blog/b { slug: 'b' }
- app/blog/[slug]/page.js /blog/c { slug: 'c' }

- 페이지마다 페이지의 경로와 값을 동적으로 할당 가능

### 6. 로딩 UI와 스트리밍

- 기존의 SSR에서는 사용자가 페이지를 보고 상호작용하기 전에 서버에서 데이터를 가져오고, 컴포넌트를 렌더링하고,HTML을 생성하고, 브라우저로 전송하는 등의 단계를 모두 완료해야 함
- 위와같은 SSR의 한계를 극복하기위해 나온것이 부분 렌더링인 스트리밍(streaming)

- loading.js와 error.js와 같은 로딩 UI는 기본적으로 스트리밍 기능을 지원

- 위의 사진처럼 로딩바운더리와 에러바운더리를 페이지 내에 컴포넌트 형식으로 사용하면 네비게이션, 사이트메뉴 등과 같은 컴포넌트를 리렌더링 할 필요가 없는 요소들을 설정할 수 있음

### 7. 병렬 라우팅

- @ 를 사용하면 페이지를 병렬로 설정 가능
- 페이지를 마치 컴포넌트 처럼 자유자재로 사용 가능

```ts
import { getUser } from '@/lib/auth';

export default function Layout({ dashboard, login }: { dashboard: React.ReactNode; login: React.ReactNode }) {
  const isLoggedIn = getUser();
  return isLoggedIn ? dashboard : login;
}
```

- 먼저, layout.js에 병렬 페이지 추가
- 위와같이 페이지를 구성하면 로그인 시 대시보드 페이지, 로그인 전일 시 로그인 페이지가 렌더링

- 더 자세한 사항은 NEXT13 공식문서 참조(https://nextjs.org/docs/app/building-your-application/routing/parallel-routes)

## typescript 간략 정리

개발 환경에서 디버그를 좀 더 수월하게 해 줌

### 1. 기본 타입 유형

원시 타입

- string 문자열
- number 숫자 값
- boolean true 와 false 값
- null null
- undefined undefined, 초기화되지 않은 변수의 기본값
- symbol 고유한 상수 값

객체 타입

- function 함수
- array 배열
- classes 클래스
- object 객체

### 2. typescript 추가 타입 유형

- any 어떤 값이든 할당 가능한 타입(js 기본 타입)

- union 두개 이상의 타입이 할당된 타입

```ts
let foo: string | number;
foo = 'Hello, World!'; // Allow
foo = 123; // Allow
foo = false; // Error
```

- tuple

```ts
let foo: [number, string];
foo = [1, 'Kim']; // Allow

let bar: [number, string][];
bar = [
  [1, 'Kim'],
  [2, 'Lee'],
]; // Allow
```

- Enum 값들의 타입 집합, 열거형

```ts
enum PrintMedia {
  Newspaper, //0
  Newsletter, //1
  Magazine, //2
  Book, //3
}
```

위와 같이 열거형은 0부터 1까지의 값을 가짐
물론, 위 enum에 초기값을 미리 할당도 가능

```ts
enum Color {
  Red = 'RED',
  Green = 'GREEN',
  Blue = 'BLUE',
}

let selectedColor: Color = Color.Red;
console.log(selectedColor); // "RED"
```

- void 함수에 리턴값이 없을 경우의 타입

- never 함수에 절대 일어나지 않는 값을 리턴 할 경우 타입
  항상 오류를 리턴하거나 절대 리턴값을 내보내지 않는다는 의미

- void와 never의 차이
  void는 null또는 undefined 리턴 가능, never는 null, undefined를 포함한 모든 값을 리턴하지 않을 때 사용

### 3. type과 interface

- interface: 주로 객체의 구조를 정의하는데 사용
- 객체뿐만 아니라 유니온, 인터섹션 등 다양한 형태의 타입을 정의, interface에 비해 좀 더 유연(Union, Intersection, Mapped Types 등)

### 4. type assertion

컴파일러가 추론한 타입을 무시하고 타입을 설정하는 기능

```ts
let anotherValue: any = 'Hello, Type Assertion!';
let strSize: number = (anotherValue as string).length; // 형식 2
console.log(strSize); // 24
```

as를 사용하여 기존에 컴파일러에서 추론된 타입 무시
strSize에서 number로 설정했음에도 에러가 나지 않음
